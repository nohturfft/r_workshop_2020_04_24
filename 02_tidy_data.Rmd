---
title: "R for Improvers (Script 2): Reshaping, cleaning and summarising data frames"
author: Axel Nohturfft (anohturf@sgul.ac.uk)
date: "`r Sys.Date()`"
output:
  html_notebook:
    code_folding: 'no'
    fig_caption: yes
    highlight: tango
    number_sections: no
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: no
---

**_Please follow the instructions in the README file before starting this tutorial._**


## Introduction: the 'tidy data' concept  
A lot of effort during data analysis projects goes into shaping input data into a format that can then be analysed with standard tools, a process known as '[data wrangling](https://en.wikipedia.org/wiki/Data_wrangling)' or 'data munging'.  

For example, the same exam results can be tabulated in the following two formats:  

|           | Question_1 | Question_2 | Question_3 | Question_4 |
|-----------|------------|------------|------------|------------|
| Student_a | A          | C          | B          | E          |
| Student_b | A          | B          | D          | E          |
| Student_c | A          | C          | D          | B          |


| Student | Question | Answer |
|---------|----------|--------|
| a       | 1        | A      |
| a       | 2        | C      |
| a       | 3        | B      |
| a       | 4        | E      |
| b       | 1        | A      |
| b       | 2        | B      |
| b       | 3        | D      |
| b       | 4        | E      |
| c       | 1        | A      |
| c       | 2        | C      |
| c       | 3        | D      |
| c       | 4        | B      |

The first table can be referred to as _**wide format**_, and the second version can be called the _**long format**_.  

_The term **TIDY DATA** is used in reference to tables arranged in such a way that each row represents an individual sample, and each column represents a variable._  

In the first table above the four question columns all contain the same type of data - students' answers to multiple choice questions. Plus, the row and column headers contain variables (student and question IDs); this table is *not* 'tidy'.  

The data would have to be converted into the format of the second (long-format) table to be conveniently analysed.  

A whole collection of R packages known as the [tidyverse](https://www.tidyverse.org/) are built around the tidy data concept ([Wickham, 2013](https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf)). These packages are very widely used in the R community.  

## Objective  
In this part of the workshop we will use two examples to illustrate how to convert data from a wide to a long (tidy) arrangement and how such data can then be summarised in tabular or graphical format.

## Code  
### Setup  
```{r chunk options, include=FALSE}
# setting rmarkdown options
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

```{r clean up memory}
# clear all variables that might be stored from a previous analysis:
rm(list=ls(all=T))
```

```{r packages, message=FALSE}
# load packages
library(magrittr)
# help(package="magrittr")
library(readr)
# help(package="readr")
library(dplyr)
# help(package="dplyr")
library(tidyr)
# help(package="tidyr")
library(stringr)
# help(package="stringr")
library(ggplot2)
# help(package="ggplot2")
```

### Time curve of phosphate data  
*(Original data kindly provided by Felix Effah)*  

#### Step 1: Load the original data.

* If you check the CSV file in Excel, you will notice that the first column does not have a header, so R makes one up ("X1").  
* Also notice that some data are missing at t0.5 and t1. R inserted NA instead.  

```{r load phosphate, message=FALSE, warning=FALSE}
phosphate <- readr::read_csv("data/phosphate_b.csv")
# View(phosphate)
print(phosphate)
```

#### Step 2: The first column contains just row numbers, so we can remove it:
```{r}
phosphate.2 <- phosphate %>% 
  dplyr::select(-X1)
# View(phosphate.2)
print(phosphate.2)
```

#### Step 3: The values in columns t0 to t5 all contain the same type of data - phosphate concentrations. Let's convert the table to a tidy (long) format using the `pivot_longer()` function from the '[tidyr](https://tidyr.tidyverse.org/)' package.
```{r}
phosphate.3 <- phosphate.2 %>% 
  tidyr::pivot_longer(-group, names_to = "Time", values_to = "Phosphate")
# View(phosphate.3)
print(phosphate.3)
```

#### Step 3: For easier inspection let's sort the data frame by group and time:  
```{r}
phosphate.4 <- phosphate.3 %>% 
  dplyr::rename(Group = group) %>% 
  dplyr::arrange(Group, Time)
# View(phosphate.4)
print(phosphate.4)
```

#### Step 4: Fix the format of the Time column  
The letter 't' in the Time column is redundant and would prevent us from plotting the data on a numerical time axis. We remove the letter 't' and convert the column to numeric format:  
(The 'stringr' package includes a whole host of useful function to manipulate text.)  

```{r}
phosphate.5 <- phosphate.4 %>% 
  dplyr::mutate(Time = stringr::str_remove(Time, "t")) %>% 
  dplyr::mutate(Time = as.numeric(Time))
# View(phosphate.5)
print(phosphate.5)
```

#### Step 5: Cleaning the table  
As noted earlier, the table includes a number of rows with missing data. Let's remove these rows.  

* There are different ways to accomplish this task. One approach using base R would be to use the `complete.cases()` function.  
* Here, we'll use `dplyr::filter()` in combination with the `is.na()` function.  
* `is.na()` returns a vector of boolean/logical values indicating whether or not the items of an input vector are NA or not.  

Example illustrating `is.na()` function:
```{r}
# Define a vector:
v <- c(1, NA, 5, 6, 0, NA)
is.na(v)
```

Inserting an exclamation mark (!) means NOT and will invert the boolean values:
```{r}
!is.na(v)
```


```{r}
phosphate.6 <- phosphate.5 %>% 
  dplyr::filter(!is.na(Phosphate))
# View(phosphate.6)
print(phosphate.6)
```


#### Step 6: Draw a boxplot  
Inspection of the data indicates that we have 20 replicates for each combination of group and time point.  
We could illustrate the spread of the data as a boxplot (keeping n mind that boxplots for for categorical x values):
```{r phosphate boxplot}
gg1 <- phosphate.6 %>% 
  dplyr::mutate(Time = factor(Time, levels=sort(unique(phosphate.6$Time)))) %>% 
  ggplot(aes(x=Time, y=Phosphate)) + geom_boxplot() + facet_wrap(~Group)
gg1
```

#### Step 7: Draw a scatterplot  
Alternatively, one might want to calculate averages for each time point and display the data as a scatterplot.  
In this case we first use the `group_by()` and `summarise()` functions from the tidyverse 'dplyr' package:  
```{r phosphate scatterplot}
phosphate.7 <- phosphate.6 %>% 
  dplyr::group_by(Group, Time) %>% 
  dplyr::summarise(Average = mean(Phosphate),
                   SD = sd(Phosphate)) %>% 
  dplyr::mutate(lower = Average - SD,
                upper = Average + SD)
# View(phosphate.6)
dplyr::select(phosphate.7, -lower, -upper)
```

```{r}
gg2 <- phosphate.7 %>% 
  ggplot(aes(x=Time, y=Average, color=Group)) +
  geom_line() +
  # geom_errorbar(aes(ymin=lower, ymax=upper, width=0.1)) +
  geom_point() +
  labs(x="Time (min)",
       y="Phosphate concentration (mM)")
gg2
```

In "real life" one would have processed the phosphate data in one continuous chain of pipes:
```{r message=FALSE, warning=FALSE}
phosphate.x <- readr::read_csv("data/phosphate_b.csv") %>% 
  dplyr::select(-X1) %>% 
  tidyr::pivot_longer(-group, names_to = "Time", values_to = "Phosphate") %>% 
  dplyr::rename(Group = group) %>% 
  dplyr::arrange(Group, Time) %>% 
  dplyr::mutate(Time = stringr::str_remove(Time, "t")) %>% 
  dplyr::mutate(Time = as.numeric(Time))

phosphate.summary <- phosphate.x %>% 
  dplyr::group_by(Group, Time) %>% 
  dplyr::summarise(Average = mean(Phosphate),
                   SD = sd(Phosphate)) %>% 
  dplyr::mutate(lower = Average - SD,
                upper = Average + SD)
```

### Merging / joining data frames  

* A very common task. One example would be to have two tables: one with gene symbols and expression data, and another with the gene symbols and gene names - your goal would be to add the gene names to expression data.  
* In general programming parlance people refer to this manipulation as performing a _**join**_.  
* The function we use in base R is `merge()`.  
* The 'dplyr' package also provides a number of join function that work well with magrittr pipes and other tidyverse functions.  

Here, let's go back to our exam files from the first script...  

#### Step 1: Load the blueprint file and select the relevant columns  
```{r open blueprint, message=FALSE}
csv.file <- "data/OSPE_Blueprint.csv"
stopifnot(file.exists(csv.file))
df.blueprint <- readr::read_csv(file=csv.file, col_names = TRUE, comment = "#") %>% 
  dplyr::select(Question, Correct_Answer)
print(df.blueprint)
```

#### Step 2: Load the file with the student answers  

* __Note__  
* that the answer data include a question/column (OSPE6) for which there is no match in the blueprint table loaded above.  
* and that the blueprint data included a question (OSPE5) for which there is no match in the results table.  

```{r open tsv, message=FALSE}
tsv.file <- "data/OSPE_Results_Raw.tsv"
stopifnot(file.exists(tsv.file))
df.results <- readr::read_tsv(file=tsv.file, col_names = TRUE, comment = "#")
print(df.results)
```

#### Step 3: Reshape student answers into 'tidy' (long) format  
```{r}
results.long <- tidyr::pivot_longer(df.results, -Cand.No, names_to = "Question", values_to = "Answer")
print(results.long)
```

#### Step 4: Merge results and blueprint  
```{r}
df.merged <- merge(x=results.long, y=df.blueprint, by="Question", all.x=FALSE, all.y=FALSE) %>% 
  dplyr::select(Cand.No, everything()) %>% 
  dplyr::arrange(Cand.No, desc(Question))
print(df.merged)
```

**Note that the merged table above contains no rows for OSPE5 or OSPE6.** By default, the `merge()` function will only include data for which it finds matches in *both* tables. This is also called an **INNER JOIN**. Decisions as to whether include all rows from one or both input tables is set by the `all.x` and `all.y` arguments to the `merge()` function.  

To illustrate the different options, let's focus on just one of the candidates (1001):  

**INNER JOIN** - Include only matches from both tables:
```{r}
merge(x=results.long, y=df.blueprint, by="Question", all.x=FALSE, all.y=FALSE) %>% 
  dplyr::select(Cand.No, everything()) %>% 
  dplyr::filter(Cand.No == 1001) %>% 
  dplyr::arrange(Question)
```

**LEFT JOIN** - Include all data from table 1 (`all.x=TRUE`), only matching rows from table 2 (`all.y=FALSE`):
```{r}
merge(x=results.long, y=df.blueprint, by="Question", all.x=TRUE, all.y=FALSE) %>% 
  dplyr::select(Cand.No, everything()) %>% 
  dplyr::filter(Cand.No == 1001) %>% 
  dplyr::arrange(Question)
```

**RIGHT JOIN** - Include all data from table 2 (`all.y=TRUE`), only matching rows from table 1 (`all.x=FALSE`):
```{r}
merge(x=results.long, y=df.blueprint, by="Question", all.x=FALSE, all.y=TRUE) %>% 
  dplyr::select(Cand.No, everything()) %>% 
  dplyr::filter(Cand.No %in% c(1001, NA)) %>%
  dplyr::arrange(Question)
```

**OUTER JOIN** - Include all data from table 1 (`all.x=TRUE`), and all data from table 2 (`all.y=TRUE`):
```{r}
merge(x=results.long, y=df.blueprint, by="Question", all.x=TRUE, all.y=TRUE) %>% 
  dplyr::select(Cand.No, everything()) %>% 
  dplyr::filter(Cand.No %in% c(1001, NA)) %>%
  dplyr::arrange(Question)
```

#### Step 5: "Mark" the answers  
```{r}
df.marked <- df.merged %>% 
  dplyr::mutate(Answer_Correct = (Answer == Correct_Answer))
print(df.marked)
```


## EXERCISE  

(1) Using the `df.marked` data above, calculate a percentage mark for each student (Cand.No).  
(2) Calculate the percent facility for each of the five exam questions (percentage of students who got the answer right).  


## Session info  
```{r}
sessionInfo()
```


